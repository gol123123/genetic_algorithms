clear all;
%====== Задание исходных параметров =======
n = 3; % Количество типов животных
m = 3; % Количество загонов
pokol = 10; % Количество покалений по которым выполняется оптимизция
i = 100; %Количество хромосом
klz = [20 30 25]; %Количество животных
product = [100 200 150; 300 280 230; 120 250 190]; %Матрица продукции с загона
rub = [600 300 650]; %Цены
minprod = [4000 3000 6000]; %Минимальная продукция
%====== /Задание исходных параметров =======
 
%====== Определения длинны хромосомы =======
lchrom=n*m; % Перемножение количества типов животных на количество загонов
%====== /Определения длинны хромосомы ======
 
%======= Создание популяции =======
% Создание массива по условию, количество животных не может превышать
% вместимость загона

for ii=1:1:1000
    x1=randi([1,20],1);
    if(x1 == 20) x2 = 0;
    else x2=randi([1,20 - x1],1); end
    x3=20-x2-x1;
    
    x4=randi([1,30],1);
    if(x4 == 30) x5 = 0;
    else x5=randi([1,30 - x4],1); end
    x6=30-x5-x4;
    
    x7=randi([1,25],1);
    if(x7 == 25) x8 = 0;
    else x8=randi([1,25 - x7],1); end
    x9=25-x7-x8;
    
    pop1(ii, 1:9)=[x1 x2 x3 x4 x5 x6 x7 x8 x9];
end
%======= /Создание популяции ======
 
%======= Эволюция =======
for npotomka = 1:1:pokol
    
    %====== решаем задачу оптимизации =====
    for chrom = 1:1:i
        
        %Ограниечение по вместимости
        ogrS1 = [pop1(chrom, 1)+ pop1(chrom, 2)+ pop1(chrom, 3)]; %Количество животных не может быть больше вместимости загона
        ogrS2 = [pop1(chrom, 4)+ pop1(chrom, 5)+ pop1(chrom, 6)]; % ---///----
        ogrS3 = [pop1(chrom, 7)+ pop1(chrom, 8)+ pop1(chrom, 9)]; % ---///----
        
        %Ограничение по минимальному объему проукции
        ogrC1 = [pop1(chrom, 1)*product(1, 1) + pop1(chrom, 4)*product(2, 1)+ pop1(chrom, 7)*product(3, 1)]; %Масса продукции, полученной с загона
        ogrC2 = [pop1(chrom, 2)*product(1, 2) + pop1(chrom, 5)*product(2, 2)+ pop1(chrom, 8)*product(3, 2)]; % ---///----
        ogrC3 = [pop1(chrom, 3)*product(1, 3) + pop1(chrom, 6)*product(2, 3)+ pop1(chrom, 9)*product(3, 3)]; % ---///----
                
        %==== условие проверки ограничений =====
        if (ogrS1 == klz(1))&&(ogrS2 == klz(2))&&(ogrS3 == klz(3))&&(ogrC1 >= minprod(1))&&(ogrC2 >= minprod(2))&&(ogrC3 >= minprod(3)) %Условия
            F = rub(1)*(product(1, 1)*pop1(chrom, 1) + product(2, 1)*pop1(chrom, 4) + product(3, 1)*pop1(chrom, 7)) + rub(2)*(product(1, 2)*pop1(chrom, 2) + product(2, 2)*pop1(chrom, 5) + product(3, 2)*pop1(chrom, 8)) + rub(3)*(product(1, 3)*pop1(chrom, 3) + product(2, 3)*pop1(chrom, 6) + product(3, 3)*pop1(chrom, 9)); %Целевая функция
            zf(chrom) = F; %Если удовлетворяет условиям, то записывается значение целевой функции
        else
            zf(chrom) = 0; %Если не удовлетворяет условиям, то записывается нулевое значение
        end
        %==== /условие проверки ограничений =====
    end
    %====== /решаем задачу оптимизации =====
    
    %====== Сортировка =====
    oldindex = 1:length(zf);   
    [b index] = sort(zf, 'descend');
    %====== /Сортировка =====
    
    %==== Запись лучшего результата
    tpobeditel = index(1);  %Выбор лучшего результата
    pobediteli(npotomka, 1:lchrom) = [pop1(tpobeditel, 1:lchrom)]; %Запись лучшего результата
    Fpobediteley(npotomka, 1) = zf(tpobeditel); % Запись значения функции оптимальноти победителя
    %==== /Запись лучшего результата
    
    %==== Запись пригодных родителей
    for rod=1:1:100
        prigod= index(rod); %выбор пригодных родителей
        roditeli(rod, 1:lchrom) =  [pop1(prigod, 1:lchrom)]; %Запись пригодных родителей
    end
     %==== Запись пригодных родителей
     
     %==== делаем детей ======
 
 
       for deti=1:1:i % перебор ..//..    
           
           mama = randi(100); %выбор случайного родителя (номер строки матрицы)
           papa = randi(100); %  ..//..
                while mama == papa % если мама равна папе, то выполняется условие...
                   mama = randi(100); %... перебор до тех пор, пока мама не станет не равна папе
                end      
           razrez = randi(lchrom-1); % случайно задаем точку разреза хромосомы
           otprisky(deti, 1:9) = [roditeli(mama, 1:razrez), roditeli(papa, (razrez+1):9)]; %Создание отпрыска (склейка строки из строк родителей)
           %otpriskynew(deti, stroka2) = otprisky(stroka2); %создание двумерной матрицы следующего поколения
               
       end 
             
     %==== Мутация =====
     genrand=randi(lchrom); %Выбор случайного гена
     chromorand=randi(100); %Выбор случайной хромосомы
     velgenrand=randi(75); %Выбор значения мутации
     otprisky(chromorand, genrand)= velgenrand; %Изменение выбранного гена в выбранной хромосоме на выбранное значение
     %==== /Мутация =====
     
     pop1 = otprisky; %Отпрыски становятся родителями  
         
end    
%======= /Эволюция =======
 
%======== Нахождение оптимального засева =======
 
oldindexOpt = 1:length(Fpobediteley);    % Индексирование лучших значений функции оптимальности по покалениям
[c indexOpt] = sort(Fpobediteley, 'descend'); % Сортировка лучших значений функций оптимальности за каждое покаления в порядке убывания
OptimumN = indexOpt(1);  %Выбор лучшего результата
Optimum = pobediteli(OptimumN, 1:lchrom);% Выбор оптимального результата из победителей 
%======== /Нахождение оптимального засева ======
 
%====== Вывод результата ======
disp(['Максимальный доход: ', num2str(Fpobediteley(OptimumN))]);
disp(' ');
disp('План заселения по загонам:');
disp('Корова Курица Баран');
disp([Optimum(1) Optimum(2) Optimum(3); Optimum(4) Optimum(5) Optimum(6); Optimum(7) Optimum(8) Optimum(9)]);
%====== /Вывод результата ======
